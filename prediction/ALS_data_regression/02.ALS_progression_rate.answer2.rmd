---
output:
  html_document:
        theme: readable
editor_options: 
  chunk_output_type: console
---

```{r}

library(tidyverse)
library(caret)
library(doParallel)
library(lightgbm)



```

```{r}
df <- read_rds(file = "prediction/ALS_data_regression/ALS_progression_rate.1822x370.rds")  %>% tbl_df()

df <- df %>% rename(response = dFRS)

head(df)
```

# Split into training and prediction set

```{r}

set.seed(0)





data_train    <- df %>% filter(!is.na(response))
data_predict  <- df %>% filter(is.na(response))                              

dim(data_predict)
dim(data_train)

```

# Example of simple prediction using the mean value

```{r}

# Always make the same split
set.seed(0)
train_index <- createDataPartition(data_train$response, p = 0.8, list = FALSE)

# We use 80% for training and 20% for evaluation
trainfold <- data_train[train_index,]
testfold  <- data_train[-train_index,]
```


```{r}
# Load the necessary package
library(glmnet)

# Prepare the training data
x_train <- model.matrix(response ~ ., trainfold)[,-1]  # predictor matrix
y_train <- trainfold$response  # response vector

# Fit the Lasso model
fit <- glmnet(x_train, y_train, alpha = 1)

# Choose the best lambda using cross-validation
cv.fit <- cv.glmnet(x_train, y_train, alpha = 1)

# Fit the final model using the best lambda
final.fit <- glmnet(x_train, y_train, alpha = 1, lambda = cv.fit$lambda.min)

# Prepare the test data
x_test <- model.matrix(response ~ ., testfold)[,-1]  # predictor matrix
y_test <- testfold$response  # response vector

# Make predictions on the test data
predictions <- predict(final.fit, newx = x_test, s = cv.fit$lambda.min)

# Calculate the residuals
residuals <- y_test - predictions

# Calculate the RMSE
rmse <- sqrt(mean(residuals^2))


test_rmse <- rmse
# Print the RMSE
print(rmse)


```



```{r}
# Install and load the necessary packages
library(lightgbm)

# Prepare the training data
train_data <- lgb.Dataset(data = model.matrix(response ~ ., trainfold)[,-1], label = trainfold$response)

# Set the parameters for the LightGBM model
params <- list(objective = "regression",
			   metric = "rmse",
			   learning_rate = 0.1,
			   num_leaves = 31,
			   bagging_fraction = 0.8,
			   feature_fraction = 0.8)

# Train the LightGBM model
model <- lgb.train(params,
				   data = train_data,
				   nrounds = 100,
				   verbose = 0)

# Prepare the test data
x_test <- model.matrix(response ~ ., testfold)[,-1]  # predictor matrix
y_test <- testfold$response  # response vector

# Make predictions on the test data
predictions <- predict(model, x_test)

# Calculate the residuals
residuals <- y_test - predictions

# Calculate the RMSE
rmse <- sqrt(mean(residuals^2))

# Print the RMSE
print(rmse)
```


randomforest
```{r}

fitControl = trainControl(method = "repeatedcv", number = 5, repeats = 3)

cl = makePSOCKcluster(5)
registerDoParallel(cl)

rf_fit <- train(response ~ ., data = trainfold, method = "rf", trControl = fitControl)
stopCluster(cl)

```

```{r}
predicted_test_rf <- predict(rf_fit, newdata = testfold)
postResample(predicted_test_rf, testfold$response)
```


GBM
```{r}
cl = makePSOCKcluster(5)
registerDoParallel(cl)

gbm_fit <- train(response ~ ., data = trainfold, method = "gbm", trControl = fitControl)
stopCluster(cl)
```

```{r}
predicted_test_gbm <- predict(gbm_fit, newdata = testfold)
postResample(predicted_test_gbm, testfold$response)
```

lightgbm

```{r}

```

```{r}

# Convert data frames to matrices
train_data <- as.matrix(trainfold[, -1])
train_label <- as.numeric(trainfold[, 1])
valid_data <- as.matrix(testfold[, -1])
valid_label <- as.numeric(testfold[, 1])

# Create datasets for lightgbm
lgb_train <- lgb.Dataset(data = as.matrix(trainfold[, -1]), label = trainfold[, 1])
lgb_valid <- lgb.Dataset(data = as.matrix(testfold[, -1]), label = testfold[, 1])

```
```{r}
# Set parameters
params <- list(objective = "regression",
			   metric = "rmse")
```
```{r}
# Train the model
lgbm_fit <- lgb.train(params,
					  data = lgb_train,
					  nrounds = 10000,
					  valids = list(validation = lgb_valid),
					  early_stopping_rounds = 100,
					  verbose = 1)
```

```{r}
# Predict on validation set
valid_pred <- predict(lgbm_fit, as.matrix(testfold[, -1]))
```
```{r}
# Calculate RMSE
rmse <- sqrt(mean((valid_pred - testfold[, 1])^2))
print(paste("Validation RMSE:", rmse))
```

lasso

```{r}
library(glmnet)

cl = makePSOCKcluster(5)
registerDoParallel(cl)

lasso_fit = train(response ~ ., data = trainfold, method = "glmnet", trControl = fitControl)

stopCluster(cl)
```

```{r}
predicted_test_fit <- predict(lasso_fit, newdata = testfold)
postResample(predicted_test_fit, testfold$response)
```

```{r}
print(paste("rf RMSE:", postResample(predicted_test_rf, testfold$response)))
print(paste("gbm RMSE:", postResample(predicted_test_gbm, testfold$response)))
#print(paste("lightgbm RMSE:", rmse))
print(paste("lasso RMSE:", postResample(predicted_test_fit, testfold$response)))
```



# Plot of testfold observed and predicted values and residuals
 

```{r}

pd  <- tibble(observed, predicted) %>% 
  mutate(residual = observed - predicted)


ggplot(pd, aes(x=predicted, y=observed)) + 
  geom_point() +
  theme_classic() +
  NULL


ggplot(pd, aes(x=predicted, y=residual)) + 
  geom_point() +
  geom_hline(yintercept = 0, linetype="dashed") +
  theme_classic() +
  NULL

rm(pd)

```

# Predict the real unknown data

First we fit the model to all of our known data

Then we predict on the unknown data

The predictions must have the following column and the row order must be the same as the original!

* predicted (the predicted value)

```{r}
  # predictor matrix
# Prepare the prediction data
x_predict <- model.matrix(~ ., data_predict[,-1])[,-1]  # predictor matrix
# Make predictions on the prediction data
predicted <- predict(final.fit, newx = x_predict, s = cv.fit$lambda.min)

# Print the predicted values
print(predicted)
```


```{r}
# Prepare the prediction data in the same way as the training data
x_predict <- model.matrix(response ~ . -1, data_predict)  # predictor matrix

# Ensure that x_predict has the same columns as x_train
missing_cols <- setdiff(colnames(x_train), colnames(x_predict))
for(col in missing_cols) {
	x_predict[, col] <- 0
}
x_predict <- x_predict[, colnames(x_train), drop = FALSE]

# Make predictions on the prediction data
predicted <- predict(final.fit, newx = x_predict, s = cv.fit$lambda.min)

# Create a tibble for the predicted values
submission <- tibble(predicted)

# Print the first few rows of the submission
head(submission)
```

```{r}

fit <-  lm(formula  = response ~ ., data = data_train)

predicted <- predict(object=fit, newdata = data_predict, type = "response")

submission <- tibble(predicted)

head(submission)

```

# Submitting your answer

The following code will give us

* your chosen team name
* the name of the people on the team
* your estimated RMSE (from train/test or CV or similar)
* your predictions

Please edit the values below .

The filename of the output will be automated als_progression.TEAMNAME.rds

Please - do not use space or funny letters in your team name.

```{r}

team_name        <- "The_Brogrammers"
team_people      <- c("Ane", "Peter")
team_error_rate  <- test_rmse
team_predictions <- submission # This should be a tibble with a column called "predicted"

#
# Always run this code
# If it fails you have done something wrong!
#
# Extract the columns needed
team_predictions <- team_predictions %>% select(predicted)

# Save all the stuff in one object
write_rds(x = list(team_name, team_people, team_error_rate, team_predictions), 
          file = paste("als_progression.", team_name, ".rds", sep=""))

```

# Checking format of all saved objects

```{r}

files   <- Sys.glob("als_progression.*.rds")
results <- tibble(filename = files, team_name=NA, team_people=NA, team_rmse=NA,n=NA, mean=NA)

for (i in 1:nrow(results)) {
  x <- read_rds(file = as.character(results$filename[i]))
  results$team_name[i]        <- x[[1]]
  results$team_people[i]      <- paste(x[[2]], collapse=",", sep=" ")
  results$team_rmse[i]        <- x[[3]]
  y                           <- x[[4]]
  results$n                   <- nrow(y)
  results$mean                <- mean(y$predicted, na.rm = T)
  results$submission[i]       <- list(x[[4]])
}

rm(x,y)

results %>% select(-filename)

results$submission[[1]]

```

# Upload your rds file!


